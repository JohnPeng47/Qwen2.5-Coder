{"repo_path": "repos\\aider", "chunked": false, "model_name": "gpt-4o-2024-08-06", "reasoning": false, "code_blocks": [{"id": "aider\\analytics.py", "content": "aider\\analytics.py:\nimport json\nimport platform\nimport sys\nimport time\nimport uuid\nfrom pathlib import Path\n\nfrom mixpanel import MixpanelException\nfrom posthog import Posthog\n\nfrom aider import __version__\nfrom aider.dump import dump  # noqa: F401\nfrom aider.models import model_info_manager\n\nPERCENT = 10\n\n\ndef compute_hex_threshold(percent):\n    \"\"\"Convert percentage to 6-digit hex threshold.\n\n    Args:\n        percent: Percentage threshold (0-100)\n\n    Returns:\n        str: 6-digit hex threshold\n    \"\"\"\n    return format(int(0xFFFFFF * percent / 100), \"06x\")\n\n\ndef is_uuid_in_percentage(uuid_str, percent):\n    \"\"\"Check if a UUID string falls within the first X percent of the UUID space.\n\n    Args:\n        uuid_str: UUID string to test\n        percent: Percentage threshold (0-100)\n\n    Returns:\n        bool: True if UUID falls within the first X percent\n    \"\"\"\n    if not (0 <= percent <= 100):\n        raise ValueError(\"Percentage must be between 0 and 100\")\n\n    if not uuid_str:\n        return False\n\n    # Convert percentage to hex threshold (1% = \"04...\", 10% = \"1a...\", etc)\n    # Using first 6 hex digits\n    if percent == 0:\n        return False\n\n    threshold = compute_hex_threshold(percent)\n    return uuid_str[:6] <= threshold\n\n\nmixpanel_project_token = \"6da9a43058a5d1b9f3353153921fb04d\"\nposthog_project_api_key = \"phc_99T7muzafUMMZX15H8XePbMSreEUzahHbtWjy3l5Qbv\"\nposthog_host = \"https://us.i.posthog.com\"\n\n\nclass Analytics:\n    # providers\n    mp = None\n    ph = None\n\n    # saved\n    user_id = None\n    permanently_disable = None\n    asked_opt_in = None\n\n    # ephemeral\n    logfile = None\n\n    def __init__(self, logfile=None, permanently_disable=False):\n        self.logfile = logfile\n        self.get_or_create_uuid()\n\n        if self.permanently_disable or permanently_disable or not self.asked_opt_in:\n            self.disable(permanently_disable)\n\n    def enable(self):\n        if not self.user_id:\n            self.disable(False)\n            return\n\n        if self.permanently_disable:\n            self.disable(True)\n            return\n\n        if not self.asked_opt_in:\n            self.disable(False)\n            return\n\n        # self.mp = Mixpanel(mixpanel_project_token)\n        self.ph = Posthog(\n            project_api_key=posthog_project_api_key,\n            host=posthog_host,\n            on_error=self.posthog_error,\n            enable_exception_autocapture=True,\n            super_properties=self.get_system_info(),  # Add system info to all events\n        )\n\n    def disable(self, permanently):\n        self.mp = None\n        self.ph = None\n\n        if permanently:\n            self.asked_opt_in = True\n            self.permanently_disable = True\n            self.save_data()\n\n    def need_to_ask(self, args_analytics):\n        if args_analytics is False:\n            return False\n\n        could_ask = not self.asked_opt_in and not self.permanently_disable\n        if not could_ask:\n            return False\n\n        if args_analytics is True:\n            return True\n\n        assert args_analytics is None, args_analytics\n\n        if not self.user_id:\n            return False\n\n        return is_uuid_in_percentage(self.user_id, PERCENT)\n\n    def get_data_file_path(self):\n        try:\n            data_file = Path.home() / \".aider\" / \"analytics.json\"\n            data_file.parent.mkdir(parents=True, exist_ok=True)\n            return data_file\n        except OSError:\n            # If we can't create/access the directory, just disable analytics\n            self.disable(permanently=False)\n            return None\n\n    def get_or_create_uuid(self):\n        self.load_data()\n        if self.user_id:\n            return\n\n        self.user_id = str(uuid.uuid4())\n        self.save_data()\n\n    def load_data(self):\n        data_file = self.get_data_file_path()\n        if not data_file:\n            return\n\n        if data_file.exists():\n            try:\n                data = json.loads(data_file.read_text())\n                self.permanently_disable = data.get(\"permanently_disable\")\n                self.user_id = data.get(\"uuid\")\n                self.asked_opt_in = data.get(\"asked_opt_in\", False)\n            except (json.decoder.JSONDecodeError, OSError):\n                self.disable(permanently=False)\n\n    def save_data(self):\n        data_file = self.get_data_file_path()\n        if not data_file:\n            return\n\n        data = dict(\n            uuid=self.user_id,\n            permanently_disable=self.permanently_disable,\n            asked_opt_in=self.asked_opt_in,\n        )\n\n        try:\n            data_file.write_text(json.dumps(data, indent=4))\n        except OSError:\n            # If we can't write the file, just disable analytics\n            self.disable(permanently=False)\n\n    def get_system_info(self):\n        return {\n            \"python_version\": sys.version.split()[0],\n            \"os_platform\": platform.system(),\n            \"os_release\": platform.release(),\n            \"machine\": platform.machine(),\n            \"aider_version\": __version__,\n        }\n\n    def _redact_model_name(self, model):\n        if not model:\n            return None\n\n        info = model_info_manager.get_model_from_cached_json_db(model.name)\n        if info:\n            return model.name\n        elif \"/\" in model.name:\n            return model.name.split(\"/\")[0] + \"/REDACTED\"\n        return None\n\n    def posthog_error(self):\n        \"\"\"disable posthog if we get an error\"\"\"\n        print(\"X\" * 100)\n        # https://github.com/PostHog/posthog-python/blob/9e1bb8c58afaa229da24c4fb576c08bb88a75752/posthog/consumer.py#L86\n        # https://github.com/Aider-AI/aider/issues/2532\n        self.ph = None\n\n    def event(self, event_name, main_model=None, **kwargs):\n        if not self.mp and not self.ph and not self.logfile:\n            return\n\n        properties = {}\n\n        if main_model:\n            properties[\"main_model\"] = self._redact_model_name(main_model)\n            properties[\"weak_model\"] = self._redact_model_name(main_model.weak_model)\n            properties[\"editor_model\"] = self._redact_model_name(main_model.editor_model)\n\n        properties.update(kwargs)\n\n        # Handle numeric values\n        for key, value in properties.items():\n            if isinstance(value, (int, float)):\n                properties[key] = value\n            else:\n                properties[key] = str(value)\n\n        if self.mp:\n            try:\n                self.mp.track(self.user_id, event_name, dict(properties))\n            except MixpanelException:\n                self.mp = None  # Disable mixpanel on connection errors\n\n        if self.ph:\n            self.ph.capture(self.user_id, event_name, dict(properties))\n\n        if self.logfile:\n            log_entry = {\n                \"event\": event_name,\n                \"properties\": properties,\n                \"user_id\": self.user_id,\n                \"time\": int(time.time()),\n            }\n            try:\n                with open(self.logfile, \"a\") as f:\n                    json.dump(log_entry, f)\n                    f.write(\"\\n\")\n            except OSError:\n                pass  # Ignore OS errors when writing to logfile\n\n\nif __name__ == \"__main__\":\n    dump(compute_hex_threshold(PERCENT))\n", "questions": ["What is the purpose of using UUIDs in determining whether a user should be asked for opt-in for analytics, and how does the `is_uuid_in_percentage` function calculate this?"]}]}